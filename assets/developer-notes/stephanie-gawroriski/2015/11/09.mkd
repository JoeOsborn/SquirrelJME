# 2015/11/09

***DISCLAIMER***: _These notes are from the defunct k8 project which_
_precedes SquirrelJME. The notes for SquirrelJME start on 2016/02/26!_
_The k8 project was effectively a Java SE 8 operating system and as such_
_all of the notes are in the context of that scope. That project is no_
_longer my goal as SquirrelJME is the spiritual successor to it._

## 00:27

Using a shell script greatly reduces the work required.

## 00:29

I could also make it output a small test program too so to speak.

## 00:32

This is the program as generated by the GNU assembler:

	41820000 419e0000 41820002 419e0002 41820001 419e0001 41820003 419e0003
	40820000 409e0000 40820002 409e0002 40820001 409e0001 40820003 409e0003
	40810000 409d0000 40810002 409d0002 40810001 409d0001 40810003 409d0003
	41800000 419c0000 41800002 419c0002 41800001 419c0001 41800003 419c0003
	40800000 409c0000 40800002 409c0002 40800001 409c0001 40800003 409c0003
	41810000 419d0000 41810002 419d0002 41810001 419d0001 41810003 419d0003

And this is it disassembled by my disassembler:

	#0000: beq:{opcd=16!, bo=12!, cr=0, bi=2!, bd=0, aa=0!, lk=0!}
	#0004: beq:{opcd=16!, bo=12!, cr=7, bi=2!, bd=0, aa=0!, lk=0!}
	#0008: beqa:{opcd=16!, bo=12!, cr=0, bi=2!, bd=0, aa=1!, lk=0!}
	#000c: beqa:{opcd=16!, bo=12!, cr=7, bi=2!, bd=0, aa=1!, lk=0!}
	#0010: beql:{opcd=16!, bo=12!, cr=0, bi=2!, bd=0, aa=0!, lk=1!}
	#0014: beql:{opcd=16!, bo=12!, cr=7, bi=2!, bd=0, aa=0!, lk=1!}
	#0018: beqla:{opcd=16!, bo=12!, cr=0, bi=2!, bd=0, aa=1!, lk=1!}
	#001c: beqla:{opcd=16!, bo=12!, cr=7, bi=2!, bd=0, aa=1!, lk=1!}
	#0020: bne:{opcd=16!, bo=4!, cr=0, bi=2!, bd=0, aa=0!, lk=0!}
	#0024: bne:{opcd=16!, bo=4!, cr=7, bi=2!, bd=0, aa=0!, lk=0!}
	#0028: bnea:{opcd=16!, bo=4!, cr=0, bi=2!, bd=0, aa=1!, lk=0!}
	#002c: bnea:{opcd=16!, bo=4!, cr=7, bi=2!, bd=0, aa=1!, lk=0!}
	#0030: bnel:{opcd=16!, bo=4!, cr=0, bi=2!, bd=0, aa=0!, lk=1!}
	#0034: bnel:{opcd=16!, bo=4!, cr=7, bi=2!, bd=0, aa=0!, lk=1!}
	#0038: bnela:{opcd=16!, bo=4!, cr=0, bi=2!, bd=0, aa=1!, lk=1!}
	#003c: bnela:{opcd=16!, bo=4!, cr=7, bi=2!, bd=0, aa=1!, lk=1!}
	#0040: ble:{opcd=16!, bo=4!, cr=0, bi=1!, bd=0, aa=0!, lk=0!}
	#0044: ble:{opcd=16!, bo=4!, cr=7, bi=1!, bd=0, aa=0!, lk=0!}
	#0048: blea:{opcd=16!, bo=4!, cr=0, bi=1!, bd=0, aa=1!, lk=0!}
	#004c: blea:{opcd=16!, bo=4!, cr=7, bi=1!, bd=0, aa=1!, lk=0!}
	#0050: blel:{opcd=16!, bo=4!, cr=0, bi=1!, bd=0, aa=0!, lk=1!}
	#0054: blel:{opcd=16!, bo=4!, cr=7, bi=1!, bd=0, aa=0!, lk=1!}
	#0058: blela:{opcd=16!, bo=4!, cr=0, bi=1!, bd=0, aa=1!, lk=1!}
	#005c: blela:{opcd=16!, bo=4!, cr=7, bi=1!, bd=0, aa=1!, lk=1!}
	#0060: blt:{opcd=16!, bo=12!, cr=0, bi=0!, bd=0, aa=0!, lk=0!}
	#0064: blt:{opcd=16!, bo=12!, cr=7, bi=0!, bd=0, aa=0!, lk=0!}
	#0068: blta:{opcd=16!, bo=12!, cr=0, bi=0!, bd=0, aa=1!, lk=0!}
	#006c: blta:{opcd=16!, bo=12!, cr=7, bi=0!, bd=0, aa=1!, lk=0!}
	#0070: bltl:{opcd=16!, bo=12!, cr=0, bi=0!, bd=0, aa=0!, lk=1!}
	#0074: bltl:{opcd=16!, bo=12!, cr=7, bi=0!, bd=0, aa=0!, lk=1!}
	#0078: bltla:{opcd=16!, bo=12!, cr=0, bi=0!, bd=0, aa=1!, lk=1!}
	#007c: bltla:{opcd=16!, bo=12!, cr=7, bi=0!, bd=0, aa=1!, lk=1!}
	#0080: bge:{opcd=16!, bo=4!, cr=0, bi=0!, bd=0, aa=0!, lk=0!}
	#0084: bge:{opcd=16!, bo=4!, cr=7, bi=0!, bd=0, aa=0!, lk=0!}
	#0088: bgea:{opcd=16!, bo=4!, cr=0, bi=0!, bd=0, aa=1!, lk=0!}
	#008c: bgea:{opcd=16!, bo=4!, cr=7, bi=0!, bd=0, aa=1!, lk=0!}
	#0090: bgel:{opcd=16!, bo=4!, cr=0, bi=0!, bd=0, aa=0!, lk=1!}
	#0094: bgel:{opcd=16!, bo=4!, cr=7, bi=0!, bd=0, aa=0!, lk=1!}
	#0098: bgela:{opcd=16!, bo=4!, cr=0, bi=0!, bd=0, aa=1!, lk=1!}
	#009c: bgela:{opcd=16!, bo=4!, cr=7, bi=0!, bd=0, aa=1!, lk=1!}
	#00a0: bgt:{opcd=16!, bo=12!, cr=0, bi=1!, bd=0, aa=0!, lk=0!}
	#00a4: bgt:{opcd=16!, bo=12!, cr=7, bi=1!, bd=0, aa=0!, lk=0!}
	#00a8: bgta:{opcd=16!, bo=12!, cr=0, bi=1!, bd=0, aa=1!, lk=0!}
	#00ac: bgta:{opcd=16!, bo=12!, cr=7, bi=1!, bd=0, aa=1!, lk=0!}
	#00b0: bgtl:{opcd=16!, bo=12!, cr=0, bi=1!, bd=0, aa=0!, lk=1!}
	#00b4: bgtl:{opcd=16!, bo=12!, cr=7, bi=1!, bd=0, aa=0!, lk=1!}
	#00b8: bgtla:{opcd=16!, bo=12!, cr=0, bi=1!, bd=0, aa=1!, lk=1!}
	#00bc: bgtla:{opcd=16!, bo=12!, cr=7, bi=1!, bd=0, aa=1!, lk=1!}

Since it is a bit long I can use a spreadsheet program to determine if it is
in fact correct.

## 00:37

Looking at the table it appears that it is correct, so this means I can use
simpler names to refer to these various branches rather than using the complex
bc stuff.

## 00:49

Next instruction to handle is GOTO, which is an alias to another and is quite
easy to implement since it is just a branch to another instruction.

## 11:28

GOTO is a relative jump for both types. Technically in this manner it is
possible for Java byte code to be really long except in common cases it is just
limited to 65KB. I messed up for all the other conditional branch types by
making them unsigned rather than signed, well treated as an absolute jump.

## 11:40

I do not use the conditions for branches at all, even when there are
conditions.

## 12:18

Going to need a slight refactor of BaseTranslator since it is getting a bit
large.

## 14:13

The class allocator should use binary names rather than class names.

## 14:16

That does not really matter much though since the class name is no longer
used.

## 14:25

Also need to check if the input arguments are of the correct class.

## 19:20

I wonder how I can do array access without calling methods over and over again.
Alternatively I can just do that for POIT to keep it simple. Also for the
special stuff, I can probably instead use a single code reference type with a
special index of the method to retrieve rather than having a couple hundred
for a bunch of things. This would at least simplify things a bit. POIT is
already slow and it can only get slower! However, POIT will meet its designated
design goal which is to be simple. Once the ABI works well enough and POIT
runs without issues, NARF can come in and make it go much faster.

## 19:25

Thinking about it since NARF will be placed on top of POIT, NARF can compile
and inline special calls generated by POIT. POIT will invoke the stuff via
the invoke interface but NARF can figure out if a special method is being
called and if it should inline that, etc. At least with the inlining the ABI
can change just by modifying the handler methods rather than rewritting
large swaths of the compiler code. The only issue are native methods, however
those can have replacements with specials which are in Java code for inlining.

## 22:06

Appears the special call stuff will remove all that mess with having tons of
varying different code references which were very similar in function.

## 22:08

For the read/write of array types I can write a script to generate the special
call stuff for that to save on some typing time, possibly.


