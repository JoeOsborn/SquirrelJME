# Design Document

This document outlines several decisions and design considerations for the
SquirrelJME Virtual Machine. This document should reflect the most recent
path that SquirrelJME will be taking in its design.

For day to day notes on my current thought process you may look within the
[developer notes](assets/developer-notes/index.mkd).

Because Java ME is different from Java SE, there are some considerations,
advantages, and disadvantages to consider when reading this document. Note that
this document is mostly within the scope of Java ME and not Java SE.

 * Reduced library subset.
   * The main library is much smaller which means it will load faster and
     use less memory. Less memory means it can run on smaller/weaker systems.
 * No reflection.
   * There is `Class.forName()` and `Class.newInstance()`, however they are
     trivial to support.
   * More secure because access checks do not have to be performed at run-time
     to determine if it is permissible to access an object.
   * Random object fields (and finals) can be cached because their reference
     or primitive values will never change.
   * More secure because for example changing `Boolean.TRUE` to be `false` may
     cause security exploits with code that relies on it being `true`.
   * The resulting virtual machine is smaller because information such as
     the types of fields and methods that exist and their type information does
     not have to be included within the virtual machine. This reduces the bloat
     within the virtual machine.
   * Produces faster code because `final` variable and especially
     `static final` values can directly be accessed rather than requiring a
     read of a field pointer value.
 * No finalizers (the `finalize()` method).
   * Finalizers are very integrated with how the garbage collector works.
   * It is never known when they will actually be called (if ever).
   * Timing attacks could be performed when finalizers are called between
     garbage collection runs.
 * No serialization.
   * No objects are `Serializable`.
   * Serialization uses virtual machine magic to access internal details, since
     there is no reflection the information that would be used for
     serialization does not exist.
   * The `transient` keyword becomes obsolete.
   * Simplifies implementation.
 * No `invokedynamic` instruction.
   * Simplifies virtual machine operation, at the cost of lambdas (which could
     be smartly wrapped in anonymous classes by a compiler).

There are also disadvantages however:

 * Without reflection, one cannot include plugins dynamically from the program.
   * However, Java ME 3 (or so) added LIBlets which may be optional and provide
     a slight alternative to plugins. These however are fixed to the JAR/JAD
     which means that the difficulty is increased.
   * Alternatively, Java ME 8 has `ServiceLoader` which enables JARs to
     potentially be merged to provide services. Also using `Class.forName()`
     and `Class.newInstance()`, plugins using a common interface can be
     initialized when they are not directly known.

For specific APIs, one should read the [Project Scope](scope.mkd) document
which outlines the APIs which exist for Java ME and whether they would be
implemented in SquirrelJME or third party vendors.

# Virtual Machine

This section contains information related to the virtual machine at compile
and run-time.

## Programming Language

SquirrelJME is written entirely in Java. This means that it only requires a
Java virtual machine and a Java compiler to be built. There are also no other
dependencies apart from what is within SquirrelJME itself, it is entirely
standalone and self contained.

## Self Hosting

I intend SquirrelJME to be self hosting in that it can build itself.

In the future a Java compiler will be written which can run on SquirrelJME
itself and allow building and compiling itself from source. This would also
allow other programs to be built from source and can be used as a self
contained Java development environment.

## Compilation

One may ask why Java and not another language such as C? Well, Java is a much
simpler language compared to C when it comes to syntax (C has the preprocessor,
structures, pointers, typedefs, function pointers, etc.). One main advantage
of Java is the consistency of the code.

One misconception about using Java is that it is impossible to use native code
or one will require and assembler to assemble assembly code for things which
Java cannot do. This is not the case for SquirrelJME. The major and most
important part of SquirrelJME is the compiler which can turn Java byte code
into native machine code. Since the compiler is very much integrated into
SquirrelJME this means that certain aspects of interacting with the host
environment can be accessed by changing compilation for certain aspects in a
way where it remains compatible with Java but also provides native access when
needed. Native access is provided by replacing method calls to special static
methods within a special class by the appropriate machine code rather than
invoking a method call. These special rewrites affect everything within the
`net.multiphasicapps.squirreljme.unsafe` package. This is used to provide
support for multiple operating systems and environments without causing name
collisions since the JIT requires renaming.

### Unsafe Renaming

In the `net.multiphasicapps.squirreljme.unsafe` package, there are classes
which are `public` and others which are internal and package private. The
internal package private classes in the form of `__Ext_<Name>__` contain
internal and to be renamed by the JIT implementations of class `<Name>`. So for
example the public class `net.multiphasicapps.squirreljme.unsafe.SystemVM`. It
internally checks and then calls methods within
`net.multiphasicapps.squirreljme.unsafe.__Ext_SystemVM__` or other internal
classes as needed. When the JIT sees a static method call to an `__Ext_` class
it will rename it according to the JIT configuration. This means that any calls
to that class end up turning into calls to
`net.multiphasicapps.squirreljme.unsafe.__Int_MIPSSystemVM__` which implements
the required classes to support the VM on MIPS systems.

This renaming in turn allows the build environment to work like a normal Java
program without requiring major rewriting or having various kludges between
the build environment and SquirrelJME. This also reduces duplicate code since
the code can be shared between the two.

## Portability

I intend for SquirrelJME to be very portable so that it can be built for and
built on a large number of systems.

## Garbage Collection

For simplicity the garbage collector is a reference counter with sweeping when
no more memory is available (or GC is called manually). As such, cyclic
object references will not be freed unless one or both directions are
weakly referenced (using `WeakReference`). This means that the following
situations would permit both objects to be potentially collected:

 * A has a strong reference to B, B does not reference A.
 * A has a weak reference to B, B does not reference A.
 * A has a strong reference to B, B has a weak reference to A.
 * A has a weak reference to B, B has a strong reference to A.
 * A and B both have weak references to each other.

Although reference counting may increase lock contention on the CPU and memory
buses it simplifies the design greatly by not requiring complex garbage
collection algorithms. In most cases with reference counting, SquirrelJME is
capable of using always a minimum footprint of memory depending on whether that
memory should be freed to the operating system or within SquirrelJME's own
memory for other programs running in it.

# Environment

This details the environment in which SquirrelJME operates within the host
operating system.

## System Services

The `net.multiphasicapps.squirreljme.unsafe.SystemEnvironment` has a method
called `<C>systemService(Class<C>)` which is used to obtain a system service.
The purpose of this class is mostly by the APIs which need to access some
implementation of an API but one which may vary across various systems and
such. This allows the API code to be very light and not require massive amounts
of branches or complexities to support multiple systems. The services means
that things can be implemented on an as used basis.

## Pathname Handling

Instances of the `Path` class will be strictly limited to the limitations of
the host system and will not provide support for allowing limitations to be
skirted as that complicates compatibility.

As an example for DOS, there are severe filename limitations such as a
maximum of 8 characters for a file name and 3 characters for an extension along
with other naming restrictions. As such getting a path which does not produce
a valid DOS pathname will result in an exception being thrown.

