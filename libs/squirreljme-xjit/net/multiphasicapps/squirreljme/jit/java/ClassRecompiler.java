// -*- Mode: Java; indent-tabs-mode: t; tab-width: 4 -*-
// ---------------------------------------------------------------------------
// Multi-Phasic Applications: SquirrelJME
//     Copyright (C) Stephanie Gawroriski <xer@multiphasicapps.net>
//     Copyright (C) Multi-Phasic Applications <multiphasicapps.net>
// ---------------------------------------------------------------------------
// SquirrelJME is under the GNU General Public License v3+, or later.
// See license.mkd for licensing and copyright information.
// ---------------------------------------------------------------------------

package net.multiphasicapps.squirreljme.jit.java;

import java.io.DataInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.LinkedHashSet;
import java.util.Set;
import net.multiphasicapps.io.region.SizeLimitedInputStream;
import net.multiphasicapps.squirreljme.jit.JITConfig;
import net.multiphasicapps.squirreljme.jit.link.ClassExtendsLink;
import net.multiphasicapps.squirreljme.jit.link.ClassFlags;
import net.multiphasicapps.squirreljme.jit.link.ClassImplementsLink;
import net.multiphasicapps.squirreljme.jit.link.ClassNameSymbol;
import net.multiphasicapps.squirreljme.jit.link.CompiledClass;
import net.multiphasicapps.squirreljme.jit.link.FieldFlags;
import net.multiphasicapps.squirreljme.jit.link.FieldSymbol;
import net.multiphasicapps.squirreljme.jit.link.IdentifierSymbol;
import net.multiphasicapps.squirreljme.jit.link.MethodFlags;
import net.multiphasicapps.squirreljme.jit.link.MethodSymbol;

/**
 * This is the part of the JIT which accepts a class file which is parsed and
 * then recompiled to native machine code as it is being processed.
 *
 * @since 2017/04/02
 */
public final class ClassRecompiler
{
	/** The magic number of the class file. */
	private static final int _MAGIC_NUMBER =
		0xCAFEBABE;
	
	/** The input class file stream. */
	protected final DataInputStream input;
	
	/** The configuration for the JIT. */
	protected final JITConfig config;
	
	/** Link table for the parsed class. */
	private volatile CompiledClass _compiledclass =
		new CompiledClass();
	
	/**
	 * Initializes the JIT processor.
	 *
	 * @param __is The input class file to process.
	 * @param __conf The configuration for the JIT.
	 * @throws NullPointerException On null arguments.
	 * @since 2017/04/02
	 */
	public ClassRecompiler(DataInputStream __is, JITConfig __conf)
		throws NullPointerException
	{
		// Check
		if (__is == null || __conf == null)
			throw new NullPointerException("NARG");
		
		// Set
		this.input = __is;
		this.config = __conf;
	}
	
	/**
	 * Runs the JIT.
	 *
	 * @return The resulting executable generated by the JIT.
	 * @throws IOException On read errors.
	 * @throws JITException If compilation failed.
	 * @since 2017/04/02
	 */
	public CompiledClass run()
		throws IOException, JITException
	{
		DataInputStream input = this.input;
		
		// {@squirreljme.error AQ0b The magic number of the input data stream
		// does not match that of the Java class file. (The magic number which
		// was read)}
		int fail;
		if ((fail = input.readInt()) != _MAGIC_NUMBER)
			throw new JITException(String.format("AQ0b %08x", fail));
		
		// {@squirreljme.error AQ0c The version number of the input class file
		// is not valid. (The version number)}
		int cver = input.readShort() | (input.readShort() << 16);
		ClassVersion version = ClassVersion.findVersion(cver);
		if (version == null)
			throw new JITException(String.format("AQ0c %d.%d",
				cver >>> 16, (cver & 0xFFFF)));
		
		// Parse the constant pool
		Pool pool = new Pool(input);
		
		// The JIT configuration
		JITConfig config = this.config;
		
		// Read class flags and the name
		ClassFlags clflags = __FlagDecoder__.__class(
			input.readUnsignedShort());
		ClassNameSymbol thisname = pool.get(input.readUnsignedShort()).
			<ClassNameSymbol>get(ClassNameSymbol.class);
		
		// {@squirreljme.error AQ0p A superclass was not specified and this
		// class is not the Object class, or a superclass was specified and
		// this is the object class.}
		ClassNameSymbol supername = pool.get(input.readUnsignedShort()).
			<ClassNameSymbol>optional(ClassNameSymbol.class);
		if ((supername == null) !=
			(thisname.equals(ClassNameSymbol.of("java/lang/Object"))))
			throw new JITException("AQ0p");
		
		// Handle interfaces
		Set<ClassNameSymbol> interfacenames = new LinkedHashSet<>();
		int n = input.readUnsignedShort();
		for (int i = 0; i < n; i++)
		{
			// Read class name
			ClassNameSymbol iname = pool.get(input.readUnsignedShort()).
				<ClassNameSymbol>get(ClassNameSymbol.class);
			
			// {@squirreljme.error AQ0r Duplicate implementation of an
			// interface. (The interface being linked)}
			if (!interfnames.add(iname))
				throw new JITException(String.format("AQ0r %s", link));
		}
		
		// Setup class export
		CompiledClass compiledclass = new CompiledClass(thisname, clflags,
			supername, interfacenames.<ClassNameSymbol>toArray(
			new ClassNameSymbol[interfacenames.size()]));
		this._compiledclass = compiledclass;
		
		// Read fields
		n = input.readUnsignedShort();
		for (int i = 0; i < n; i++)
		{
			// Read field information
			FieldFlags ff = __FlagDecoder__.__field(clflags,
				input.readUnsignedShort());
			IdentifierSymbol name = IdentifierSymbol.of(pool.get(
				input.readUnsignedShort()).<String>get(String.class));
			FieldSymbol type = FieldSymbol.of(pool.get(
				input.readUnsignedShort()).<String>get(String.class));
			
			// Create field
			ExportedField field = new ExportedField(compiledclass,
				ff, name, type);
			compiledclass.export(field);
			
			// Handle attributes
			int[] count = new int[]{input.readUnsignedShort()};
			String[] aname = new String[1];
			while ((count[0]--) > 0)
				try (DataInputStream as = __nextAttribute(input, pool, aname))
				{
					// Only use constant values
					if (!aname[0].equals("ConstantValue"))
						continue;
					
					// {@squirreljme.error AQ0v The field already has a
					// constant value assigned to it. (The field)}
					if (field._value != null)
						throw new JITException(
							String.format("AQ0v %s", field));
					
					// Read the constant value index
					Object val = pool.get(as.readUnsignedShort()).
						<Object>get(Object.class);
					
					// {@squirreljme.error AQ0w Illegal constant value type.
					// (The class type)}
					if (!(val instanceof String) &&
						!(val instanceof Integer) &&
						!(val instanceof Long) &&
						!(val instanceof Float) &&
						!(val instanceof Double))
						throw new JITException(String.format("AQ0w %s",
							val.getClass()));
					
					// Set
					field._value = val;
				}
		}
		
		// Read methods
		n = input.readUnsignedShort();
		for (int i = 0; i < n; i++)
		{
			// Read method information
			MethodFlags mf = __FlagDecoder__.__method(clflags,
				input.readUnsignedShort());
			IdentifierSymbol name = IdentifierSymbol.of(pool.get(
				input.readUnsignedShort()).<String>get(String.class));
			MethodSymbol type = MethodSymbol.of(pool.get(
				input.readUnsignedShort()).<String>get(String.class));
			
			// Create method
			ExportedMethod method = new ExportedMethod(compiledclass, mf, name,
				type);
			compiledclass.export(method);
			
			// Handle attributes
			int[] count = new int[]{input.readUnsignedShort()};
			String[] aname = new String[1];
			while ((count[0]--) > 0)
				try (DataInputStream as = __nextAttribute(input, pool, aname))
				{
					// Only code is handled
					if (!aname[0].equals("Code"))
						continue;
					
					// Setup decoder
					new __Code__(method, as, pool, compiledclass, config).
						__run();
				}
		}
		
		// Ignore attributes at the end of the class
		int[] count = new int[]{input.readUnsignedShort()};
		String[] aname = new String[1];
		while ((count[0]--) > 0)
			try (DataInputStream as = __nextAttribute(input, pool, aname))
			{
			}
		
		// {@squirreljme.error AQ0t Extra bytes at the end of the class file.}
		if (input.read() >= 0)
			throw new JITException("AQ0t");
		
		// Generate final executable
		throw new todo.TODO();
	}
	
	/**
	 * Reads the next attribute from the class.
	 *
	 * @param __in The input stream where bytes come from.
	 * @param __pool The constant pool.
	 * @param __aname The output name of the attribute which was just read.
	 * @return The stream to the attribute which just has been read.
	 * @throws IOException On read errors.
	 * @throws JITException If the attribute is not correct.
	 * @throws NullPointerException On null arguments.
	 * @since 2017/04/09
	 */
	static DataInputStream __nextAttribute(DataInputStream __in,
		Pool __pool, String[] __aname)
		throws IOException, JITException, NullPointerException
	{
		// Check
		if (__aname == null)
			throw new NullPointerException("NARG");
		
		// The name is not parsed here
		__aname[0] = __pool.get(__in.readUnsignedShort()).get(String.class);
		
		// {@squirreljme.error AQ0u Attribute exceeds 2GiB in length. (The
		// size of the attribute)}
		int len = __in.readInt();
		if (len < 0)
			throw new JITException(String.format("AQ0u %d",
				len & 0xFFFFFFFFL));
		
		// Setup reader
		return new DataInputStream(new SizeLimitedInputStream(__in, len, true,
			false));
	}
}

